/*
 * Package : Cbor
 * Author : S. Hamblett <steve.hamblett@linux.com>
 * Date   : 12/12/2016
 * Copyright :  S.Hamblett
 */

import 'package:cbor/cbor.dart';
import 'package:collection/collection.dart';
import 'package:meta/meta.dart';

import '../encoder/sink.dart';
import '../utils/info.dart';
import 'internal.dart';

/// A CBOR array.
abstract class CborList implements List<CborValue>, CborValue {
  /// Create a new [CborList] from a view of the given list.
  const factory CborList(List<CborValue> items, {List<int> tags}) = _CborList;

  /// Create a new [CborList] from values.
  ///
  /// The resulting list is growable.
  factory CborList.of(Iterable<CborValue> elements, {List<int> tags}) =
      _CborList.of;

  /// Create a new [CborList] from generator.
  ///
  /// The resulting list is growable.
  factory CborList.generate(int len, CborValue Function(int index) f,
      {List<int> tags}) = _CborList.generate;
}

class _CborList extends DelegatingList<CborValue>
    with CborValueMixin
    implements CborList {
  const _CborList(List<CborValue> items, {this.tags = const []}) : super(items);

  _CborList.of(Iterable<CborValue> elements, {this.tags = const []})
      : super(List.of(elements));
  _CborList.generate(
    int len,
    CborValue Function(int index) f, {
    this.tags = const [],
  }) : super(List.generate(len, f));

  /// <nodoc>
  @internal
  @override
  Object? toObjectInternal(Set<Object> cyclicCheck, ToObjectOptions o) {
    if (!cyclicCheck.add(this)) {
      throw CborCyclicError(this);
    }

    final res = map((i) => i.toObjectInternal(cyclicCheck, o)).toList();

    cyclicCheck.remove(this);

    return res;
  }

  @override
  final List<int> tags;

  /// <nodoc>
  @internal
  @override
  void encode(EncodeSink sink) {
    if (length < 256) {
      CborEncodeDefiniteLengthList(this).encode(sink);
    } else {
      // Indefinite length
      CborEncodeIndefiniteLengthList(this).encode(sink);
    }
  }
}

/// Use this to force the [CborEncoder] to encode an indefinite length list.
///
/// This is never generated by decoder.
class CborEncodeIndefiniteLengthList with CborValueMixin implements CborValue {
  CborEncodeIndefiniteLengthList(this.inner);

  final CborList inner;

  /// <nodoc>
  @internal
  @override
  Object? toObjectInternal(Set<Object> cyclicCheck, ToObjectOptions o) {
    throw UnimplementedError();
  }

  /// <nodoc>
  @internal
  @override
  void encode(EncodeSink sink) {
    sink.addTags(tags);

    sink.addHeaderInfo(4, Info.indefiniteLength);

    sink.addToCycleCheck(inner);
    for (final x in inner) {
      x.encode(sink);
    }

    sink.removeFromCycleCheck(inner);

    (const Break()).encode(sink);
  }

  @override
  int? get expectedConversion => inner.expectedConversion;

  @override
  List<int> get tags => inner.tags;
}

/// Use this to force the [CborEncoder] to encode an definite length list.
///
/// This is never generated by decoder.
class CborEncodeDefiniteLengthList with CborValueMixin implements CborValue {
  const CborEncodeDefiniteLengthList(this.inner);

  final CborList inner;

  /// <nodoc>
  @internal
  @override
  Object? toObjectInternal(Set<Object> cyclicCheck, ToObjectOptions o) {
    throw UnimplementedError();
  }

  /// <nodoc>
  @internal
  @override
  void encode(EncodeSink sink) {
    sink.addTags(tags);

    sink.addHeaderInfo(4, Info.int(inner.length));

    sink.addToCycleCheck(inner);
    for (final x in inner) {
      x.encode(sink);
    }
    sink.removeFromCycleCheck(inner);
  }

  @override
  int? get expectedConversion => inner.expectedConversion;

  @override
  List<int> get tags => inner.tags;
}

/// A CBOR fraction (m * (10 ** e)).
abstract class CborDecimalFraction extends CborList {
  factory CborDecimalFraction({
    required CborInt exponent,
    required CborInt mantissa,
    List<int> tags,
  }) = _CborDecimalFraction;

  CborInt get exponent;

  CborInt get mantissa;
}

class _CborDecimalFraction extends DelegatingList<CborValue>
    with CborValueMixin
    implements CborDecimalFraction {
  _CborDecimalFraction({
    required this.exponent,
    required this.mantissa,
    this.tags = const [CborTag.decimalFraction],
  }) : super(List.of([exponent, mantissa], growable: false));

  @override
  final CborInt exponent;
  @override
  final CborInt mantissa;

  @override
  final List<int> tags;

  /// <nodoc>
  @internal
  @override
  Object? toObjectInternal(Set<Object> cyclicCheck, ToObjectOptions o) {
    return [exponent.toInt(), mantissa.toBigInt()];
  }

  /// <nodoc>
  @internal
  @override
  void encode(EncodeSink sink) {
    sink.addTags(tags);
    sink.addHeaderInfo(4, Info.int(2));
    exponent.encode(sink);
    mantissa.encode(sink);
  }
}

/// A CBOR fraction (m * (2 ** e)).
abstract class CborBigFloat extends CborList {
  factory CborBigFloat({
    required CborInt exponent,
    required CborInt mantissa,
    List<int> tags,
  }) = _CborBigFloat;

  CborInt get exponent;
  CborInt get mantissa;
}

class _CborBigFloat extends DelegatingList<CborValue>
    with CborValueMixin
    implements CborBigFloat {
  _CborBigFloat({
    required this.exponent,
    required this.mantissa,
    this.tags = const [CborTag.bigFloat],
  }) : super(List.of([exponent, mantissa], growable: false));

  @override
  final CborInt exponent;
  @override
  final CborInt mantissa;

  @override
  final List<int> tags;

  /// <nodoc>
  @internal
  @override
  Object? toObjectInternal(Set<Object> cyclicCheck, ToObjectOptions o) {
    return [exponent.toInt(), mantissa.toBigInt()];
  }

  /// <nodoc>
  @override
  @internal
  void encode(EncodeSink sink) {
    sink.addTags(tags);
    sink.addHeaderInfo(4, Info.int(2));
    exponent.encode(sink);
    mantissa.encode(sink);
  }
}
