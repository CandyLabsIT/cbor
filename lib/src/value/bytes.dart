/*
 * Package : Cbor
 * Author : S. Hamblett <steve.hamblett@linux.com>
 * Date   : 12/12/2016
 * Copyright :  S.Hamblett
 */

import 'dart:typed_data';

import 'package:cbor/cbor.dart';
import 'package:collection/collection.dart';

import '../encoder/sink.dart';
import '../utils/info.dart';
import 'value.dart';

/// A CBOR byte array.
class CborBytes with CborValueMixin implements CborValue {
  const CborBytes(this.bytes, [this.tags = const []]);

  final List<int> bytes;
  @override
  String toString() => bytes.toString();
  @override
  bool operator ==(Object other) =>
      other is CborBytes && bytes.equals(other.bytes);
  @override
  int get hashCode => bytes.hashCode;
  @override
  final List<int> tags;

  @override
  void encode(EncodeSink sink) {
    CborEncodeDefiniteLengthBytes(this).encode(sink);
  }
}

/// Use this to force the [CborEncoder] to encode an indefinite length byte string.
///
/// This is never generated by decoder.
class CborEncodeIndefiniteLengthBytes with CborValueMixin implements CborValue {
  CborEncodeIndefiniteLengthBytes(this.items, [this.tags = const []]);

  final List<List<int>> items;
  @override
  final List<int> tags;

  @override
  void encode(EncodeSink sink) {
    sink.addTags(tags);

    sink.addHeaderInfo(2, Info.indefiniteLength);

    for (final value in items) {
      CborEncodeDefiniteLengthBytes(CborBytes(value)).encode(sink);
    }

    (const Break()).encode(sink);
  }
}

/// Use this to force the [CborEncoder] to encode an definite length byte string.
///
/// This is never generated by decoder.
class CborEncodeDefiniteLengthBytes implements CborValue {
  const CborEncodeDefiniteLengthBytes(this.inner);

  final CborBytes inner;

  @override
  void encode(EncodeSink sink) {
    sink.addTags(tags);

    sink.addHeaderInfo(2, Info.int(inner.bytes.length));

    sink.add(inner.bytes);
  }

  @override
  int? get expectedConversion => inner.expectedConversion;

  @override
  List<int> get tags => inner.tags;
}

/// A CBOR big int.
class CborBigInt extends CborBytes implements CborInt {
  const CborBigInt._(List<int> bytes, this._isNegative, List<int> tags)
      : super(bytes, tags);

  factory CborBigInt(
    BigInt value, [
    List<int>? tags,
  ]) {
    final negative = value.isNegative;
    if (value.isNegative) {
      tags ??= [CborTag.negativeBignum];
      value = ~value;
    } else {
      tags ??= [CborTag.positiveBignum];
    }

    final b = Uint8List((value.bitLength + 7) ~/ 8);

    for (var i = b.length - 1; i >= 0; i--) {
      b[i] = value.toUnsigned(8).toInt();
      value >>= 8;
    }

    return CborBigInt._(b, negative, tags);
  }

  const CborBigInt.fromBytes(
    List<int> bytes, [
    List<int> tags = const [CborTag.positiveBignum],
  ]) : this._(bytes, false, tags);

  const CborBigInt.fromNegativeBytes(
    List<int> bytes, [
    List<int> tags = const [CborTag.negativeBignum],
  ]) : this._(bytes, true, tags);

  final bool _isNegative;

  @override
  bool operator ==(Object other) =>
      other is CborBigInt &&
      bytes.equals(other.bytes) &&
      _isNegative == other._isNegative;

  @override
  BigInt toBigInt() {
    var data = BigInt.zero;
    for (final b in bytes) {
      data <<= 8;
      data |= BigInt.from(b);
    }

    return _isNegative ? ~data : data;
  }

  @override
  int toInt() => toBigInt().toInt();
}
