import 'package:cbor/cbor.dart';
import 'package:collection/collection.dart';
import 'package:meta/meta.dart';

import '../encoder/sink.dart';
import '../utils/info.dart';
import 'internal.dart';

/// A CBOR map.
abstract class CborMap implements Map<CborValue, CborValue>, CborValue {
  /// Create a new [CborMap] from a view of the given map.
  const factory CborMap(Map<CborValue, CborValue> items, {List<int> tags}) =
      _CborMap;

  /// Create a new [CborMap] as a copy of the given map.
  factory CborMap.of(Map<CborValue, CborValue> items, {List<int> tags}) =
      _CborMap.of;

  /// Create a new [CborMap] from entries.
  factory CborMap.fromEntries(Iterable<MapEntry<CborValue, CborValue>> entries,
      {List<int> tags}) = _CborMap.fromEntries;

  /// Create a new [CborMap] from key and value.
  factory CborMap.fromIterables(
      Iterable<CborValue> key, Iterable<CborValue> values,
      {List<int> tags}) = _CborMap.fromIterables;
}

class _CborMap extends DelegatingMap<CborValue, CborValue>
    with CborValueMixin
    implements CborMap {
  const _CborMap(Map<CborValue, CborValue> items, {this.tags = const []})
      : super(items);
  _CborMap.of(Map<CborValue, CborValue> items, {this.tags = const []})
      : super(Map.of(items));
  _CborMap.fromEntries(Iterable<MapEntry<CborValue, CborValue>> entries,
      {this.tags = const []})
      : super(Map.fromEntries(entries));
  _CborMap.fromIterables(
    Iterable<CborValue> keys,
    Iterable<CborValue> values, {
    this.tags = const [],
  }) : super(Map.fromIterables(keys, values));

  /// <nodoc>
  @internal
  @override
  Object? toObjectInternal(Set<Object> cyclicCheck, ToObjectOptions o) {
    if (!cyclicCheck.add(this)) {
      throw CborCyclicError(this);
    }

    final result = Map.fromEntries(entries.map((a) => MapEntry(
          a.key.toObjectInternal(cyclicCheck, o),
          a.value.toObjectInternal(cyclicCheck, o),
        )));

    cyclicCheck.remove(this);

    return result;
  }

  @override
  final List<int> tags;

  /// <nodoc>
  @internal
  @override
  void encode(EncodeSink sink) {
    if (length < 256) {
      CborEncodeDefiniteLengthMap(this).encode(sink);
    } else {
      CborEncodeIndefiniteLengthMap(this).encode(sink);
    }
  }
}

/// Use this to force the [CborEncoder] to encode an indefinite length dictionary.
///
/// This is never generated by decoder.
class CborEncodeIndefiniteLengthMap with CborValueMixin implements CborValue {
  CborEncodeIndefiniteLengthMap(this.inner);

  final CborMap inner;

  /// <nodoc>
  @internal
  @override
  Object? toObjectInternal(Set<Object> cyclicCheck, ToObjectOptions o) {
    throw UnimplementedError();
  }

  /// <nodoc>
  @internal
  @override
  void encode(EncodeSink sink) {
    sink.addTags(tags);

    sink.addHeaderInfo(5, Info.indefiniteLength);

    sink.addToCycleCheck(inner);
    for (final e in inner.entries) {
      e.key.encode(sink);
      e.value.encode(sink);
    }
    sink.removeFromCycleCheck(inner);

    (const Break()).encode(sink);
  }

  @override
  int? get expectedConversion => inner.expectedConversion;

  @override
  List<int> get tags => inner.tags;
}

/// Use this to force the [CborEncoder] to encode an definite length dictionary.
///
/// This is never generated by decoder.
class CborEncodeDefiniteLengthMap with CborValueMixin implements CborValue {
  const CborEncodeDefiniteLengthMap(this.inner);

  final CborMap inner;

  /// <nodoc>
  @internal
  @override
  Object? toObjectInternal(Set<Object> cyclicCheck, ToObjectOptions o) {
    throw UnimplementedError();
  }

  /// <nodoc>
  @internal
  @override
  void encode(EncodeSink sink) {
    sink.addTags(tags);

    sink.addHeaderInfo(5, Info.int(inner.length));

    sink.addToCycleCheck(inner);
    for (final e in inner.entries) {
      e.key.encode(sink);
      e.value.encode(sink);
    }
    sink.removeFromCycleCheck(inner);
  }

  @override
  int? get expectedConversion => inner.expectedConversion;

  @override
  List<int> get tags => inner.tags;
}
