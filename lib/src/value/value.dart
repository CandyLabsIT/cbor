/*
 * Package : Cbor
 * Author : S. Hamblett <steve.hamblett@linux.com>
 * Date   : 12/12/2016
 * Copyright :  S.Hamblett
 */

import 'package:cbor/cbor.dart';
import 'package:collection/collection.dart';
import 'package:meta/meta.dart';

import '../encoder/sink.dart';
import '../utils/info.dart';
import '../utils/utils.dart';
import 'simple_value.dart';

export 'bytes.dart';
export 'double.dart';
export 'int.dart';
export 'list.dart';
export 'simple_value.dart';
export 'string.dart';

/// Hint for the content of something.
@sealed
class CborTag {
  CborTag._();

  static const int dateTimeString = 0;
  static const int epochDateTime = 1;
  static const int positiveBignum = 2;
  static const int negativeBignum = 3;
  static const int decimalFraction = 4;
  static const int bigFloat = 5;
  static const int encodedCborData = 24;
  static const int expectedConversionToBase64 = 22;
  static const int expectedConversionToBase64Url = 21;
  static const int expectedConversionToBase16 = 23;
  static const int uri = 32;
  static const int base64Url = 33;
  static const int base64 = 34;
  static const int regex = 35;
  static const int mime = 36;
  static const int selfDescribeCbor = 55799;
}

/// A CBOR value.
@sealed
abstract class CborValue {
  /// Additional tags provided to the value.
  List<int> get tags;

  /// Hint to a expected conversion when converting to JSON.
  int? get expectedConversion;

  /// <nodoc>
  @internal
  void encode(EncodeSink sink);
}

/// <nodoc>
@internal
mixin CborValueMixin implements CborValue {
  @override
  int? get expectedConversion {
    for (final tag in tags.reversed) {
      if (isExpectConversion(tag)) {
        return tag;
      }
    }
  }
}

/// A CBOR datetime.
abstract class CborDateTime with CborValueMixin implements CborValue {
  /// Converts the value to [DateTime], throwing [FormatException] if fails.
  DateTime toDateTime();
}

/// A CBOR map.
class CborMap extends DelegatingMap<CborValue, CborValue>
    with CborValueMixin
    implements CborValue {
  const CborMap(
      [Map<CborValue, CborValue> items = const {}, this.tags = const []])
      : super(items);
  CborMap.fromEntries(Iterable<MapEntry<CborValue, CborValue>> entries,
      [this.tags = const []])
      : super(Map.fromEntries(entries));

  @override
  final List<int> tags;

  @override
  void encode(EncodeSink sink) {
    if (length < 256) {
      CborEncodeDefiniteLengthMap(this).encode(sink);
    } else {
      CborEncodeIndefiniteLengthMap(this).encode(sink);
    }
  }
}

/// Use this to force the [CborEncoder] to encode an indefinite length dictionary.
///
/// This is never generated by decoder.
class CborEncodeIndefiniteLengthMap implements CborValue {
  CborEncodeIndefiniteLengthMap(this.inner);

  final CborMap inner;

  @override
  void encode(EncodeSink sink) {
    sink.addTags(tags);

    sink.addHeaderInfo(5, Info.indefiniteLength);

    sink.addToCycleCheck(inner);
    for (final e in inner.entries) {
      e.key.encode(sink);
      e.value.encode(sink);
    }
    sink.removeFromCycleCheck(inner);

    (const Break()).encode(sink);
  }

  @override
  int? get expectedConversion => inner.expectedConversion;

  @override
  List<int> get tags => inner.tags;
}

/// Use this to force the [CborEncoder] to encode an definite length dictionary.
///
/// This is never generated by decoder.
class CborEncodeDefiniteLengthMap implements CborValue {
  const CborEncodeDefiniteLengthMap(this.inner);

  final CborMap inner;

  @override
  void encode(EncodeSink sink) {
    sink.addTags(tags);

    sink.addHeaderInfo(5, Info.int(inner.length));

    sink.addToCycleCheck(inner);
    for (final e in inner.entries) {
      e.key.encode(sink);
      e.value.encode(sink);
    }
    sink.removeFromCycleCheck(inner);
  }

  @override
  int? get expectedConversion => inner.expectedConversion;

  @override
  List<int> get tags => inner.tags;
}
